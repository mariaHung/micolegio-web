/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import earthcartoon from "../../assets/3d/earth-cartoon.glb" 
import { useFrame, useThree } from '@react-three/fiber';
import { a } from "@react-spring/three";

const EarthCartoon = ({ isRotating, setIsRotating, setCurrentStage, ...props}) => {
  const { nodes, materials } = useGLTF(earthcartoon);

  const earthRef = useRef();
  const { gl, viewport } = useThree();

  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95
  const autoRotateSpeed = 0.001;

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);

    const clientX = e.touches
      ? e.touches[0].clientX
      : e.clientX;

    lastX.current = clientX
  };

  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
  }

  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if(isRotating) {
      const clientX = e.touches
        ? e.touches[0].clientX
        : e.clientX;

      const delta = (clientX - lastX.current) / viewport.width;

      earthRef.current.rotation.y += delta * 0.01 * Math.PI;
      lastX.current = clientX;
      rotationSpeed.current = delta * 0.01 * Math.PI;
    }
  }

  const handleKeyDown = (e) => {
    if(e.key === "ArrowLeft") {
      if(!isRotating) setIsRotating(true);
      earthRef.current.rotation.y += 0.01 *Math.PI;
    } else if(e.key === "ArrowRight") {
      if(isRotating) setIsRotating(false);
      earthRef.current.rotation.y -= 0.01 * Math.PI
    }
  }
  const handleKeyUp= (e) => {
    if(e.key === "ArrowLeft" || e.key === "ArrowRight") {
      setIsRotating(false);
    }
  }

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown', handlePointerDown)
    canvas.addEventListener('pointerup', handlePointerUp)
    canvas.addEventListener('pointermove', handlePointerMove)
    canvas.addEventListener('keydown', handleKeyDown)
    canvas.addEventListener('keyup', handleKeyUp)

    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown)
      canvas.removeEventListener('pointerup', handlePointerUp)
      canvas.removeEventListener('pointermove', handlePointerMove)
      canvas.removeEventListener('keydown', handleKeyDown)
      canvas.removeEventListener('keyup', handleKeyUp)
    }
  }, [gl, handlePointerDown, handlePointerMove, handlePointerUp])

  useFrame(() => {
    if(!isRotating) {
      rotationSpeed.current *= dampingFactor;

      if(Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }

      earthRef.current.rotation.y += autoRotateSpeed;
      earthRef.current.rotation.y += rotationSpeed.current;

    }else{
      const rotation = earthRef.current.rotation.y;
    /**
       * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
       * The goal is to ensure that the rotation value remains within a specific range to
       * prevent potential issues with very large or negative rotation values.
       *  Here's a step-by-step explanation of what this code does:
       *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
       *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
       *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
       *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
       *     This is done to ensure that the value remains positive and within the range of
       *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
       *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
       *     modulo operation to the value obtained in step 2. This step guarantees that the value
       *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
       *     circle in radians.
       */
    const normalizedRotation =
    ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

     // Set the current stage based on the island's orientation
     switch (true) {
       case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
         setCurrentStage(4);
         break;
       case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
         setCurrentStage(3);
         break;
       case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
         setCurrentStage(2);
         break;
       case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
         setCurrentStage(1);
         break;
       default:
         setCurrentStage(null);
     }
   }
 })

  return (
    <a.group ref={earthRef} {...props}>
        <mesh
          name="Oceano"
          castShadow
          receiveShadow
          geometry={nodes.Oceano.geometry}
          material={materials.agua}>
          <mesh
            name="tierra"
            castShadow
            receiveShadow
            geometry={nodes.tierra.geometry}
            material={materials.tierra}
            scale={0.996}
          />
        </mesh>
        <mesh
          name="barco"
          castShadow
          receiveShadow
          geometry={nodes.barco.geometry}
          material={materials.Atlas_1}
          position={[0.644, -0.215, -0.719]}
          rotation={[-1.679, 0.395, 0.896]}
          scale={[0.015, 0.021, 0.016]}
        />
        <mesh
          name="barco009"
          castShadow
          receiveShadow
          geometry={nodes.barco009.geometry}
          material={materials['Atlas.2']}
          position={[0.848, 0.333, 0.4]}
          rotation={[-1.408, -0.59, -1.937]}
          scale={0.01}
        />
        <group
          name="Armature001"
          position={[0.564, 0.451, 0.62]}
          rotation={[0.708, -0.369, -0.737]}
          scale={0.01}>
          <skinnedMesh
            name="colaBallena001"
            geometry={nodes.colaBallena001.geometry}
            material={materials.ballena}
            skeleton={nodes.colaBallena001.skeleton}
          />
          <primitive object={nodes.Main} />
        </group>
        <group
          name="Armature002"
          position={[-0.846, -0.218, -0.378]}
          rotation={[2.298, 0.497, 1.648]}
          scale={0.01}>
          <skinnedMesh
            name="colaBallena002"
            geometry={nodes.colaBallena002.geometry}
            material={materials.ballena}
            skeleton={nodes.colaBallena002.skeleton}
          />
          <primitive object={nodes.Main_1} />
        </group>
        <group
          name="Armature003"
          position={[0.43, -0.474, -0.704]}
          rotation={[-0.216, 1.029, -1.973]}
          scale={0.01}>
          <skinnedMesh
            name="colaBallena003"
            geometry={nodes.colaBallena003.geometry}
            material={materials.ballena}
            skeleton={nodes.colaBallena003.skeleton}
          />
          <primitive object={nodes.Main_2} />
        </group>
        <mesh
          name="avion003"
          castShadow
          receiveShadow
          geometry={nodes.avion003.geometry}
          material={materials['Atlas.2']}
          position={[-0.409, -1.016, 0.477]}
          rotation={[-0.438, 0, 2.792]}
          scale={0.018}>
          <mesh
            name="avion004"
            castShadow
            receiveShadow
            geometry={nodes.avion004.geometry}
            material={materials['ox-logo']}
          />
          <mesh
            name="Cube009"
            castShadow
            receiveShadow
            geometry={nodes.Cube009.geometry}
            material={materials['Atlas.2']}
            position={[-3.44, -0.807, 0]}
            rotation={[2.338, 0, 0]}
            scale={[0.319, 0.221, 0.221]}
          />
        </mesh>
        <mesh
          name="ox-logo008"
          castShadow
          receiveShadow
          geometry={nodes['ox-logo008'].geometry}
          material={materials['Atlas.2']}
          position={[-0.954, 0.859, 0.547]}
          rotation={[2.135, 0.755, 0.825]}
          scale={0.141}
        />
        <mesh
          name="ox-logo009"
          castShadow
          receiveShadow
          geometry={nodes['ox-logo009'].geometry}
          material={materials['Atlas.2']}
          position={[-0.842, 0.381, -1.049]}
          rotation={[0.344, 0.653, 0.461]}
          scale={0.141}
        />
        <mesh
          name="edificio001"
          castShadow
          receiveShadow
          geometry={nodes.edificio001.geometry}
          material={materials['Atlas.2']}
          position={[0.969, 0.299, 0.303]}
          rotation={[0.057, -0.309, -1.25]}
          scale={[0.007, 0.018, 0.007]}
        />
        <mesh
          name="avion001"
          castShadow
          receiveShadow
          geometry={nodes.avion001.geometry}
          material={materials['ox-logo']}
          position={[0.01, 0.636, 1.074]}
          rotation={[1.036, 0, 0]}
          scale={0.018}
        />
        <mesh
          name="ox-logo001"
          castShadow
          receiveShadow
          geometry={nodes['ox-logo001'].geometry}
          material={materials['ox-logo']}
          position={[-0.954, 0.859, 0.547]}
          rotation={[2.135, 0.755, 0.825]}
          scale={0.141}
        />
        <mesh
          name="ox-logo002"
          castShadow
          receiveShadow
          geometry={nodes['ox-logo002'].geometry}
          material={materials['ox-logo']}
          position={[-0.842, 0.381, -1.049]}
          rotation={[0.344, 0.653, 0.461]}
          scale={0.141}
        />
        <mesh
          name="avion002"
          castShadow
          receiveShadow
          geometry={nodes.avion002.geometry}
          material={materials['Atlas.2']}
          position={[0.01, 0.636, 1.074]}
          rotation={[1.036, 0, 0]}
          scale={0.018}>
          <mesh
            name="Cube001"
            castShadow
            receiveShadow
            geometry={nodes.Cube001.geometry}
            material={materials['Atlas.2']}
            position={[-3.44, -0.807, 0]}
            rotation={[2.338, 0, 0]}
            scale={[0.319, 0.221, 0.221]}
          />
        </mesh>
        <mesh
          name="arbol007"
          castShadow
          receiveShadow
          geometry={nodes.arbol007.geometry}
          material={materials.vegetación}
          position={[0.851, 0.605, -0.005]}
          rotation={[0.173, 0.354, -1.1]}
          scale={0.011}
        />
        <mesh
          name="Icosphere004"
          castShadow
          receiveShadow
          geometry={nodes.Icosphere004.geometry}
          material={materials.nube}
          position={[-0.012, 1.161, 0.6]}
          rotation={[Math.PI / 2, -1.053, Math.PI / 2]}
          scale={[0.045, 0.035, 0.045]}
        />
        <mesh
          name="nube002"
          castShadow
          receiveShadow
          geometry={nodes.nube002.geometry}
          material={materials.nube}
          position={[-0.003, 0, 1.572]}
          rotation={[2.489, -1.503, -0.655]}
          scale={[-0.023, -0.017, -0.023]}
        />
        <mesh
          name="Icosphere006"
          castShadow
          receiveShadow
          geometry={nodes.Icosphere006.geometry}
          material={materials.nube}
          position={[1.421, 0.599, -0.52]}
          rotation={[-3.11, -0.434, -3.05]}
          scale={[0.063, 0.055, 0.052]}
        />
        <mesh
          name="nube003"
          castShadow
          receiveShadow
          geometry={nodes.nube003.geometry}
          material={materials.nube}
          position={[0.587, -0.527, -1.197]}
          rotation={[0.076, 0.992, 3.078]}
          scale={[-0.018, -0.013, -0.018]}
        />
        <mesh
          name="Icosphere007"
          castShadow
          receiveShadow
          geometry={nodes.Icosphere007.geometry}
          material={materials.nube}
          position={[-0.495, -1.3, -0.305]}
          rotation={[0.594, -0.483, 0.304]}
          scale={[0.05, 0.039, 0.05]}
        />
        <mesh
          name="Icosphere008"
          castShadow
          receiveShadow
          geometry={nodes.Icosphere008.geometry}
          material={materials.nube}
          position={[-1.436, -0.22, -0.172]}
          rotation={[0.518, 0.025, -0.014]}
          scale={[0.045, 0.035, 0.045]}
        />
        <mesh
          name="Icosphere009"
          castShadow
          receiveShadow
          geometry={nodes.Icosphere009.geometry}
          material={materials.nube}
          position={[0.952, 0.357, 1.09]}
          rotation={[2.426, 0.715, -2.624]}
          scale={[0.045, 0.035, 0.045]}
        />
        <mesh
          name="nube004"
          castShadow
          receiveShadow
          geometry={nodes.nube004.geometry}
          material={materials.nube}
          position={[-0.487, 0.642, -1.03]}
          rotation={[0.098, -1.134, -3.052]}
          scale={[-0.023, -0.017, -0.023]}
        />
        <mesh
          name="nube005"
          castShadow
          receiveShadow
          geometry={nodes.nube005.geometry}
          material={materials.nube}
          position={[-1.119, -0.737, 0.257]}
          rotation={[0.043, 0.22, 3.129]}
          scale={[-0.023, -0.017, -0.023]}
        />
    </a.group>
  )
}

useGLTF.preload('/earth-cartoon.glb')
export default EarthCartoon;

